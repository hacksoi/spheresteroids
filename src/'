#include <windows.h>
#include <assert.h>
#define Assert assert
#define _USE_MATH_DEFINES
#include <math.h>
#include <stdint.h>
#include <stdio.h>

#include "glcorearb.h"
#include "wglext.h"

#include "util.h"
#include "game_math.h"
#include "renderer_opengl.cpp"

global_variable HWND GlobalDummyWindow;
global_variable HWND GlobalWindow;
global_variable HDC GlobalDeviceContext;
global_variable HGLRC GlobalRenderingContext;

global_variable uint64_t GlobalQueryPerformanceFrequency;

global_variable bool GlobalRunning = true;

internal uint64_t
GetCurrentCounter()
{
	LARGE_INTEGER LargeInteger;
	QueryPerformanceCounter(&LargeInteger);
	uint64_t Result = LargeInteger.QuadPart;

	return Result;
}

internal float
GetSecondsElapsed(uint64_t NewCounter, uint64_t OldCounter)
{
	float Result = ((float)(NewCounter - OldCounter) / (float)GlobalQueryPerformanceFrequency);

	return Result;
}

internal float
GetMillisecondsElapsed(uint64_t NewCounter, uint64_t OldCounter)
{
	float Result = GetSecondsElapsed(NewCounter, OldCounter) * 1000.0f;

	return Result;
}

LRESULT
MainWindowProcedure(HWND hWnd, 
					UINT uMsg, 
					WPARAM wParam, 
					LPARAM lParam)
{
	if(!GlobalDummyWindow)
	{
		GlobalDummyWindow = hWnd;
	}

	LRESULT Result = 1;

	if(hWnd != GlobalDummyWindow)
	{
		switch(uMsg)
		{
			case WM_SIZE:
			{
				RECT WindowRectangle;
				GetClientRect(hWnd, &WindowRectangle);
				glViewport(0, 0, WindowRectangle.right, WindowRectangle.bottom);
			} break;

			case WM_KEYDOWN:
			{
				switch(wParam)
				{
					case VK_LEFT:
					{
					} break;
				} break;
			} break;

			case WM_CLOSE:
			case WM_DESTROY:
			{
				GlobalRunning = false;
			} break;

			default:
			{
				Result = DefWindowProc(hWnd, uMsg, wParam, lParam);
			} break;
		}
	}
	else
	{
		Result = DefWindowProc(hWnd, uMsg, wParam, lParam);
	}

	return Result;
}

int
WinMain(HINSTANCE hInstance, 
		HINSTANCE hPrevInstance, 
		LPSTR lpCmdLine, 
		int nCmdShow)
{
	char AppName[] = "Asteroids";

	MMRESULT SetSleepGranularityResult = timeBeginPeriod(1);
	if(SetSleepGranularityResult == TIMERR_NOCANDO)
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	LARGE_INTEGER LargeInteger;
	QueryPerformanceFrequency(&LargeInteger);
	GlobalQueryPerformanceFrequency = LargeInteger.QuadPart;

	WNDCLASS WindowClass = {};
	WindowClass.style = CS_OWNDC;
	WindowClass.lpfnWndProc = (WNDPROC)MainWindowProcedure;
	WindowClass.cbClsExtra = 0;
	WindowClass.cbWndExtra = 0;
	WindowClass.hInstance = hInstance;
	WindowClass.lpszMenuName = AppName;
	WindowClass.lpszClassName = AppName;

	if(!RegisterClass(&WindowClass))
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	int WindowWidth = 720;
	int WindowHeight = 720;

	HWND DummyWindow = CreateWindow(AppName,
									"Asteroids",
									WS_OVERLAPPEDWINDOW,
									CW_USEDEFAULT,
									CW_USEDEFAULT,
									WindowWidth,
									WindowHeight,
									NULL,
									NULL,
									hInstance,
									NULL);

	// NOTE: Using the DummyWindow to my advantage here to get Monitor Resolution before creating the real window
	HMONITOR Monitor = MonitorFromWindow(DummyWindow, MONITOR_DEFAULTTONEAREST);
	MONITORINFO MonitorInfo;
	MonitorInfo.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(Monitor, &MonitorInfo);
	int MonitorWidth = MonitorInfo.rcMonitor.right - MonitorInfo.rcMonitor.left;
	int MonitorHeight = MonitorInfo.rcMonitor.bottom - MonitorInfo.rcMonitor.top;

	if(!DummyWindow)
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	HDC DummyDeviceContext = GetDC(DummyWindow);

	PIXELFORMATDESCRIPTOR DummyPixelFormatDescriptor;
	DummyPixelFormatDescriptor.nSize = sizeof(PIXELFORMATDESCRIPTOR);
	DummyPixelFormatDescriptor.nVersion = 1;
	DummyPixelFormatDescriptor.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
	DummyPixelFormatDescriptor.iPixelType = PFD_TYPE_RGBA;
	DummyPixelFormatDescriptor.cColorBits = 32;
	DummyPixelFormatDescriptor.cDepthBits = 24;
	DummyPixelFormatDescriptor.cStencilBits = 8;

	int DummyPixelFormat = ChoosePixelFormat(DummyDeviceContext, &DummyPixelFormatDescriptor);

	if(DummyPixelFormat == 0)
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	if(SetPixelFormat(DummyDeviceContext, DummyPixelFormat, &DummyPixelFormatDescriptor) == FALSE)
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	HGLRC DummyRenderingContext = wglCreateContext(DummyDeviceContext);
	if(DummyRenderingContext == 0)
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	wglMakeCurrent(DummyDeviceContext, DummyRenderingContext);

	InitializeOpenGLFunctions();

	if(!DestroyWindow(DummyWindow))
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	int WindowX = (MonitorWidth - WindowWidth) / 2;
	int WindowY = (MonitorHeight - WindowHeight) / 2;
	GlobalWindow = CreateWindow(AppName,
								"Asteroids",
								WS_OVERLAPPEDWINDOW,
								WindowX,
								WindowY,
								WindowWidth,
								WindowHeight,
								NULL,
								NULL,
								hInstance,
								NULL);

	GlobalDeviceContext = GetDC(GlobalWindow);
	if(!GlobalDeviceContext)
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	const int PixelFormatAttributeList[] = 
	{
		WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
		WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
		WGL_DOUBLE_BUFFER_ARB, GL_TRUE,
		WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
		WGL_COLOR_BITS_ARB, 32,
		WGL_DEPTH_BITS_ARB, 24,
		WGL_STENCIL_BITS_ARB, 8,
		0
	};

	int PixelFormat;
	UINT NumFormats;
	wglChoosePixelFormatARB(GlobalDeviceContext, PixelFormatAttributeList, NULL, 1, &PixelFormat, &NumFormats);

	if(SetPixelFormat(GlobalDeviceContext, PixelFormat, NULL) == FALSE)
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	const int ContextAttributeList[] = 
	{
		WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
		WGL_CONTEXT_MAJOR_VERSION_ARB, 3,
		WGL_CONTEXT_MINOR_VERSION_ARB, 2,
		0
	};

	GlobalRenderingContext = wglCreateContextAttribsARB(GlobalDeviceContext, NULL, ContextAttributeList);
	if(GlobalRenderingContext == 0)
	{
		// TODO: Logging
		Assert(false);
		return FALSE;
	}

	wglMakeCurrent(GlobalDeviceContext, GlobalRenderingContext);

	wglSwapIntervalEXT(1);

	ShowWindow(GlobalWindow, SW_SHOW);

	glEnable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);
	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

	const GLchar *VertexShaderSource =
		"#version 330 core\n\
		layout (location = 0) in vec2 Position;\n\
		uniform mat4 Model;\n\
		void main()\n\
		{\n\
			gl_Position = Model * vec4(Position, 0.0f, 1.0f);\n\
		}";

	const GLchar *FragmentShaderSource = 
		"#version 330 core\n\
		out vec4 OutColor;\n\
		void main()\n\
		{\n\
			OutColor = vec4(1.0f, 0.5f, 0.5f, 1.0f);\n\
		}";

	GLuint ShaderProgram = CreateShaderProgram(VertexShaderSource, FragmentShaderSource);

	GLfloat TriangleVertices[] = 
	{
		-0.25f, -0.25f,
		0.25f, -0.25f,
		0.0f, 0.25f
	};

	GLuint VertexBuffer = 0;
	GLuint VertexArray = 0;

	glGenBuffers(1, &VertexBuffer);
	glGenVertexArrays(1, &VertexArray);
	glBindVertexArray(VertexArray);
	glBindBuffer(GL_ARRAY_BUFFER, VertexBuffer);
	glBufferData(GL_ARRAY_BUFFER, sizeof(TriangleVertices), TriangleVertices, GL_STATIC_DRAW);
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), (GLvoid *)0);
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);

	uint32_t FramesPerSecond = 60;
	float SecondsPerFrame = 1.0f / (float)FramesPerSecond;
	float MillisecondsPerFrame = SecondsPerFrame * 1000.0f;
	float MillisecondsSlackForVsync = 2.0f;
	float RealMillisecondsPerFrame = MillisecondsPerFrame - MillisecondsSlackForVsync;
	uint64_t FrameStartCounter = GetCurrentCounter();

	float PlayerX = 0;
	float PlayerY = 0;

	bool Left = false;
	bool Right = true;

	char DebugBuffer[256];
	while(GlobalRunning)
	{
		MSG Message;
		while(PeekMessage(&Message, NULL, 0, 0, PM_REMOVE) == TRUE)
		{
			switch(Message.message)
			{
				case WM_KEYDOWN:
				case WM_KEYUP:
				{
					OutputDebugString("KEY!!!");
				} break;

				default:
				{
					TranslateMessage(&Message);
					DispatchMessage(&Message);
				} break;
			}
		}

		if(PlayerX <= -1.0f) { Left = false; Right = true; }
		if(PlayerX >= 1.0f) { Right = false; Left = true; }

		float PlayerSpeed = 0.025f;
		if(Left) { PlayerX -= PlayerSpeed; }
		else if(Right) { PlayerX += PlayerSpeed; }

		mat4 Model;
		Translate(&Model, V3(PlayerX, PlayerY, 0.0f));
		Transpose(&Model);

		GLint ModelLocation = glGetUniformLocation(ShaderProgram, "Model");
		glUseProgram(ShaderProgram);
		glUniformMatrix4fv(ModelLocation, 1, GL_FALSE, Model.Elements);

		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glBindVertexArray(VertexArray);
		glDrawArrays(GL_TRIANGLES, 0, 3);
		glBindVertexArray(0);

		bool MissedFrame = false;
		float FrameMillisecondsElapsed = GetMillisecondsElapsed(GetCurrentCounter(), FrameStartCounter);
		if(FrameTimeElapsed < SecondsPerFrame)
		{
			float MillisecondsToSleepFloat = ((MillisecondsPerFrame - FrameMillisecondsElapsed)) - 1.0f;
			if(MillisecondsToSleepFloat > 0.0f)
			{
				DWORD MillisecondsToSleep = (DWORD)MillisecondsToSleepFloat;
				Sleep(MillisecondsToSleep);
				Assert(GetSecondsElapsed(GetCurrentCounter(), FrameStartCounter) < SecondsPerFrame);
			}

			while(GetSecondsElapsed(GetCurrentCounter(), FrameStartCounter) < SecondsPerFrame)
			{
				// spin-lock
			}
		}
		else
		{
			// TODO: Logging
			MissedFrame = true;
		}
		if(MissedFrame)
		{
			float FrameMillisecondsElapsed = GetMillisecondsElapsed(GetCurrentCounter(), FrameStartCounter);
			_snprintf_s(DebugBuffer, sizeof(DebugBuffer), "Missed Frame: %.08fms\n", FrameMillisecondsElapsed);
			OutputDebugString(DebugBuffer);
		}
		//uint64_t Start = GetCurrentCounter();
		//float MillisecondsElapsed = GetMillisecondsElapsed(GetCurrentCounter(), Start);
		//_snprintf_s(DebugBuffer, sizeof(DebugBuffer), "%.08fms\n", MillisecondsElapsed);
		//OutputDebugString(DebugBuffer);

		FrameStartCounter = GetCurrentCounter();

		uint64_t CountBeforeSwap = GetCurrentCounter();
		SwapBuffers(GlobalDeviceContext);
		float SwapMillisecondsElapsed = GetMillisecondsElapsed(GetCurrentCounter(), CountBeforeSwap);
		if(SwapMillisecondsElapsed > 0.5f)
		{
			OutputDebugString("Out of sync with VBLANKs! Syncing...\n");
			FrameStartCounter = GetCurrentCounter();
		}
	}

	return 0;
}
